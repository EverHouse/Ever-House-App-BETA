You are absolutely right. The current configuration explicitly disables all background synchronization in production, which is why your live app isn't updating.

Here is the complete implementation plan to enable production syncing, add the missing manual endpoint, and document the update.

### **1. Enable Sync in Production (`server/index.ts`)**

This change moves the calendar synchronization logic **outside** of the `if (!isProduction)` block so it runs in your live environment. It keeps the "Auto Seeding" (fake data) restricted to development.

```typescript
import express from 'express';
import cors from 'cors';
import compression from 'compression';
import path from 'path';
import { fileURLToPath } from 'url';
import { getSession, registerAuthRoutes } from './replit_integrations/auth';
import { setupSupabaseAuthRoutes } from './supabase/auth';
import { isProduction, pool } from './core/db';
import { requestIdMiddleware, logRequest } from './core/logger';
import { db } from './db';
import { systemSettings } from '../shared/schema';
import { eq, sql } from 'drizzle-orm';
import { syncGoogleCalendarEvents, syncWellnessCalendarEvents, syncInternalCalendarToClosures } from './core/calendar';

import resourcesRouter from './routes/resources';
import calendarRouter from './routes/calendar';
import eventsRouter from './routes/events';
import authRouter from './routes/auth';
import hubspotRouter from './routes/hubspot';
import membersRouter from './routes/members';
import usersRouter from './routes/users';
import wellnessRouter from './routes/wellness';
import guestPassesRouter from './routes/guestPasses';
import baysRouter from './routes/bays';
import notificationsRouter from './routes/notifications';
import pushRouter, { sendDailyReminders } from './routes/push';
import availabilityRouter from './routes/availability';
import cafeRouter from './routes/cafe';
import dataConflictsRouter from './routes/dataConflicts';
import galleryRouter from './routes/gallery';
import announcementsRouter from './routes/announcements';
import faqsRouter from './routes/faqs';
import inquiriesRouter from './routes/inquiries';
import imageUploadRouter from './routes/imageUpload';
import closuresRouter from './routes/closures';
import membershipTiersRouter from './routes/membershipTiers';
import trainingRouter, { seedTrainingSections } from './routes/training';
import toursRouter, { syncToursFromCalendar, sendTodayTourReminders } from './routes/tours';
import bugReportsRouter from './routes/bugReports';
import trackmanRouter from './routes/trackman';
import { registerObjectStorageRoutes } from './replit_integrations/object_storage';
import { ensureDatabaseConstraints } from './db-init';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();

app.set('trust proxy', 1);

type CorsCallback = (err: Error | null, allow?: boolean) => void;
type CorsOriginFunction = (origin: string | undefined, callback: CorsCallback) => void;

const getAllowedOrigins = (): string[] | boolean | CorsOriginFunction => {
  if (!isProduction) {
    return true;
  }
  const origins = process.env.ALLOWED_ORIGINS;
  if (origins && origins.trim()) {
    return origins.split(',').map(o => o.trim()).filter(Boolean);
  }
  const replitDomain = process.env.REPLIT_DEV_DOMAIN;
  if (replitDomain) {
    return [`https://${replitDomain}`, `https://${replitDomain.replace('-00-', '-')}`];
  }
  return (origin: string | undefined, callback: (err: Error | null, allow?: boolean) => void) => {
    if (!origin) {
      callback(null, true);
      return;
    }
    try {
      const url = new URL(origin);
      const hostname = url.hostname;
      if (hostname.endsWith('.replit.app') || hostname.endsWith('.replit.dev') || hostname.endsWith('.repl.co')) {
        callback(null, true);
        return;
      }
      if (hostname === 'localhost' || hostname === '127.0.0.1') {
        callback(null, true);
        return;
      }
    } catch {
      // Invalid URL, deny
    }
    callback(new Error('Not allowed by CORS'));
  };
};

const corsOptions = {
  origin: getAllowedOrigins(),
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization']
};

app.use(requestIdMiddleware);
app.use(logRequest);
app.use(cors(corsOptions));
app.use(compression());
app.use(express.json({ limit: '1mb' }));
app.use(express.urlencoded({ limit: '1mb' }));
app.use(getSession());

app.get('/healthz', (req, res) => {
  res.status(200).json({ status: 'ok' });
});

app.get('/api/health', async (req, res) => {
  try {
    const dbResult = await pool.query('SELECT NOW() as time, COUNT(*) as resource_count FROM resources');
    const resourceTypes = await pool.query('SELECT type, COUNT(*) as count FROM resources GROUP BY type');
    res.json({
      status: 'ok',
      environment: isProduction ? 'production' : 'development',
      database: 'connected',
      timestamp: dbResult.rows[0].time,
      resourceCount: parseInt(dbResult.rows[0].resource_count),
      resourcesByType: resourceTypes.rows,
      databaseUrl: process.env.DATABASE_URL ? 'configured' : 'missing'
    });
  } catch (error: any) {
    res.status(500).json({
      status: 'error',
      environment: isProduction ? 'production' : 'development',
      database: 'disconnected',
      error: error.message,
      databaseUrl: process.env.DATABASE_URL ? 'configured' : 'missing'
    });
  }
});

if (isProduction) {
  app.use(express.static(path.join(__dirname, '../dist')));
} else {
  app.get('/', (req, res) => {
    const devDomain = process.env.REPLIT_DEV_DOMAIN;
    if (devDomain) {
      res.redirect(`https://${devDomain}`);
    } else {
      res.send('API Server running. Frontend is at port 5000.');
    }
  });
}

app.use(resourcesRouter);
app.use(calendarRouter);
app.use(eventsRouter);
app.use(authRouter);
app.use(hubspotRouter);
app.use(membersRouter);
app.use(usersRouter);
app.use(wellnessRouter);
app.use(guestPassesRouter);
app.use(baysRouter);
app.use(notificationsRouter);
app.use(pushRouter);
app.use(availabilityRouter);
app.use(cafeRouter);
app.use(dataConflictsRouter);
app.use(galleryRouter);
app.use(announcementsRouter);
app.use(faqsRouter);
app.use(inquiriesRouter);
app.use(imageUploadRouter);
app.use(closuresRouter);
app.use(membershipTiersRouter);
app.use(trainingRouter);
app.use(toursRouter);
app.use(bugReportsRouter);
app.use(trackmanRouter);
registerObjectStorageRoutes(app);

if (isProduction) {
  app.use((req, res, next) => {
    if (req.method === 'GET' && !req.path.startsWith('/api/') && !req.path.startsWith('/healthz')) {
      return res.sendFile(path.join(__dirname, '../dist/index.html'));
    }
    next();
  });
}

async function autoSeedResources() {
  try {
    const result = await pool.query('SELECT COUNT(*) as count FROM resources');
    const count = parseInt(result.rows[0].count);
    
    if (count === 0) {
      console.log('Auto-seeding resources...');
      const resources = [
        { name: 'Simulator Bay 1', type: 'simulator', description: 'TrackMan Simulator Bay 1', capacity: 6 },
        { name: 'Simulator Bay 2', type: 'simulator', description: 'TrackMan Simulator Bay 2', capacity: 6 },
        { name: 'Simulator Bay 3', type: 'simulator', description: 'TrackMan Simulator Bay 3', capacity: 6 },
        { name: 'Simulator Bay 4', type: 'simulator', description: 'TrackMan Simulator Bay 4', capacity: 6 },
        { name: 'Conference Room', type: 'conference_room', description: 'Main conference room with AV setup', capacity: 12 },
      ];

      for (const resource of resources) {
        await pool.query(
          `INSERT INTO resources (name, type, description, capacity) 
           VALUES ($1, $2, $3, $4) 
           ON CONFLICT DO NOTHING`,
          [resource.name, resource.type, resource.description, resource.capacity]
        );
      }
      console.log(`Auto-seeded ${resources.length} resources (4 simulators + 1 conference room)`);
    }
  } catch (error) {
    console.log('Resources table may not exist yet, skipping auto-seed');
  }
}

async function autoSeedCafeMenu() {
  try {
    const result = await pool.query('SELECT COUNT(*) as count FROM cafe_items');
    const count = parseInt(result.rows[0].count);
    
    if (count === 0) {
      console.log('Auto-seeding cafe menu...');
      const cafeItems = [
        { category: 'Breakfast', name: 'Egg Toast', price: 14, description: 'Schaner Farm scrambled eggs, whipped ricotta, chives, micro greens, toasted country batard', icon: 'egg_alt', sort_order: 1 },
        // ... (truncated for brevity, same list as before)
      ];

      for (const item of cafeItems) {
        await pool.query(
          `INSERT INTO cafe_items (category, name, price, description, icon, is_active, sort_order) 
           VALUES ($1, $2, $3, $4, $5, true, $6) 
           ON CONFLICT DO NOTHING`,
          [item.category, item.name, item.price, item.description, item.icon, item.sort_order]
        );
      }
      console.log(`Auto-seeded ${cafeItems.length} cafe menu items`);
    }
  } catch (error) {
    console.log('Cafe menu table may not exist yet, skipping auto-seed');
  }
}

async function autoSeedTrainingSectionsWrapper() {
  try {
    const result = await pool.query('SELECT COUNT(*) as count FROM training_sections');
    const count = parseInt(result.rows[0].count);
    
    if (count === 0) {
      console.log('Auto-seeding training sections...');
      await seedTrainingSections();
      console.log('Auto-seeded training sections');
    }
  } catch (error) {
    console.log('Training sections table may not exist yet, skipping auto-seed');
  }
}

async function startServer() {
  console.log(`[Startup] Environment: ${isProduction ? 'production' : 'development'}`);
  console.log(`[Startup] DATABASE_URL: ${process.env.DATABASE_URL ? 'configured' : 'MISSING'}`);
  console.log(`[Startup] PORT env: ${process.env.PORT || 'not set'}`);
  
  await ensureDatabaseConstraints();
  
  try {
    setupSupabaseAuthRoutes(app);
    registerAuthRoutes(app);
  } catch (err) {
    console.error('[Startup] FATAL: Auth routes setup failed:', err);
    process.exit(1);
  }

  const PORT = isProduction 
    ? Number(process.env.PORT) 
    : (Number(process.env.PORT) || 3001);
  
  if (isProduction && !process.env.PORT) {
    console.error('[Startup] FATAL: PORT environment variable required in production');
    process.exit(1);
  }
  
  const server = app.listen(PORT, '0.0.0.0', () => {
    console.log(`[Startup] API Server running on port ${PORT}`);
  });

  server.on('error', (err: any) => {
    console.error(`[Startup] Server failed to start:`, err);
    process.exit(1);
  });

  // 1. Development-only Auto-seeding
  if (!isProduction) {
    setTimeout(async () => {
      try { await autoSeedResources(); } catch (err) { console.error('[Startup] Auto-seed resources failed:', err); }
      try { await autoSeedCafeMenu(); } catch (err) { console.error('[Startup] Auto-seed cafe menu failed:', err); }
      try { await autoSeedTrainingSectionsWrapper(); } catch (err) { console.error('[Startup] Auto-seed training sections failed:', err); }
    }, 100);
  }

  // 2. Calendar Sync (Enabled in BOTH Development and Production)
  setTimeout(async () => {
    console.log('[Startup] Initializing calendar sync...');
    
    // Initial Sync on Startup
    try {
      const gcalResult = await syncGoogleCalendarEvents();
      if (gcalResult.error) console.log(`[Startup] Google Calendar sync skipped: ${gcalResult.error}`);
      else console.log(`[Startup] Google Calendar sync: ${gcalResult.synced} events`);
    } catch (err) { console.log('[Startup] Google Calendar sync failed:', err); }

    try {
      const closuresResult = await syncInternalCalendarToClosures();
      if (closuresResult.error) console.log(`[Startup] Internal Calendar closures sync skipped: ${closuresResult.error}`);
      else console.log(`[Startup] Internal Calendar closures sync: ${closuresResult.synced} events`);
    } catch (err) { console.log('[Startup] Internal Calendar closures sync failed:', err); }

    try {
      const toursResult = await syncToursFromCalendar();
      if (toursResult.error) console.log(`[Startup] Tours sync skipped: ${toursResult.error}`);
      else console.log(`[Startup] Tours sync: ${toursResult.synced} tours`);
    } catch (err) { console.log('[Startup] Tours sync failed:', err); }

    try {
      const wellnessResult = await syncWellnessCalendarEvents();
      if (wellnessResult.error) console.log(`[Startup] Wellness sync skipped: ${wellnessResult.error}`);
      else console.log(`[Startup] Wellness sync: ${wellnessResult.synced} classes`);
    } catch (err) { console.log('[Startup] Wellness sync failed:', err); }

    // Start Interval (Every 5 minutes)
    const SYNC_INTERVAL_MS = 5 * 60 * 1000;
    setInterval(async () => {
      try {
        // Run syncs in parallel
        const [events, wellness, tours, closures] = await Promise.all([
          syncGoogleCalendarEvents().catch(e => ({ error: e.message, synced: 0 })),
          syncWellnessCalendarEvents().catch(e => ({ error: e.message, synced: 0 })),
          syncToursFromCalendar().catch(e => ({ error: e.message, synced: 0 })),
          syncInternalCalendarToClosures().catch(e => ({ error: e.message, synced: 0 }))
        ]);

        console.log(`[Auto-sync] Events: ${events.synced}, Wellness: ${wellness.synced}, Tours: ${tours.synced}, Closures: ${closures.synced}`);
      } catch (err) {
        console.error('[Auto-sync] Calendar sync cycle failed:', err);
      }
    }, SYNC_INTERVAL_MS);
    
    console.log('[Startup] Background calendar sync enabled (every 5 minutes)');
  }, 1000);
  
  // Daily reminder scheduler - runs at 6pm local time
  const REMINDER_HOUR = 18; // 6pm
  const REMINDER_SETTING_KEY = 'last_daily_reminder_date';
  
  const tryClaimReminderSlot = async (todayStr: string): Promise<boolean> => {
    try {
      const result = await db
        .insert(systemSettings)
        .values({
          key: REMINDER_SETTING_KEY,
          value: todayStr,
          updatedAt: new Date(),
        })
        .onConflictDoUpdate({
          target: systemSettings.key,
          set: {
            value: todayStr,
            updatedAt: new Date(),
          },
          where: sql`${systemSettings.value} IS DISTINCT FROM ${todayStr}`,
        })
        .returning({ key: systemSettings.key });
      
      return result.length > 0;
    } catch (err) {
      console.error('[Daily Reminders] Database error:', err);
      return false;
    }
  };
  
  const checkAndSendReminders = async () => {
    try {
      const now = new Date();
      const currentHour = now.getHours();
      const todayStr = now.toISOString().split('T')[0];
      
      if (currentHour === REMINDER_HOUR) {
        const claimed = await tryClaimReminderSlot(todayStr);
        
        if (claimed) {
          console.log('[Daily Reminders] Starting scheduled reminder job...');
          try {
            const result = await sendDailyReminders();
            console.log(`[Daily Reminders] Completed: ${result.message}`);
          } catch (err) {
            console.error('[Daily Reminders] Send failed:', err);
          }
        }
      }
    } catch (err) {
      console.error('[Daily Reminders] Scheduler error:', err);
    }
  };
  
  setInterval(checkAndSendReminders, 30 * 60 * 1000);
  console.log('[Startup] Daily reminder scheduler enabled (runs at 6pm)');
}

startServer().catch((err) => {
  console.error('[Startup] Fatal error:', err);
  process.exit(1);
});

```

### **2. Add Manual Closure Sync Endpoint (`server/routes/closures.ts`)**

This allows you to force a sync immediately from the frontend (or via Postman) without waiting 5 minutes.

```typescript
import { Router } from 'express';
import { isProduction } from '../core/db';
import { db } from '../db';
import { facilityClosures, pushSubscriptions, users, bays, availabilityBlocks, announcements, notifications, resources } from '../../shared/schema';
import { eq, desc, or, isNull, inArray } from 'drizzle-orm';
import webpush from 'web-push';
import { isStaffOrAdmin } from '../core/middleware';
import { getCalendarIdByName, deleteCalendarEvent, CALENDAR_CONFIG, syncInternalCalendarToClosures } from '../core/calendar';
import { getGoogleCalendarClient } from '../core/integrations';
import { createPacificDate, parseLocalDate, addDaysToPacificDate } from '../utils/dateUtils';

const router = Router();

export async function sendPushNotificationToAllMembers(payload: { title: string; body: string; url?: string }) {
  try {
    const subscriptions = await db
      .select({
        endpoint: pushSubscriptions.endpoint,
        p256dh: pushSubscriptions.p256dh,
        auth: pushSubscriptions.auth
      })
      .from(pushSubscriptions)
      .innerJoin(users, eq(pushSubscriptions.userEmail, users.email))
      .where(or(eq(users.role, 'member'), isNull(users.role)));
    
    const notifications = subscriptions.map(async (sub) => {
      const pushSubscription = {
        endpoint: sub.endpoint,
        keys: {
          p256dh: sub.p256dh,
          auth: sub.auth
        }
      };
      
      try {
        await webpush.sendNotification(pushSubscription, JSON.stringify(payload));
      } catch (err: any) {
        if (err.statusCode === 410) {
          await db.delete(pushSubscriptions).where(eq(pushSubscriptions.endpoint, sub.endpoint));
        }
      }
    });
    
    await Promise.all(notifications);
    console.log(`[Push] Sent notification to ${subscriptions.length} members`);
  } catch (error) {
    console.error('Failed to send push notification to members:', error);
  }
}

async function getConferenceRoomId(): Promise<number | null> {
  const result = await db
    .select({ id: resources.id })
    .from(resources)
    .where(eq(resources.type, 'conference_room'))
    .limit(1);
  return result.length > 0 ? result[0].id : null;
}

async function getAffectedBayIds(affectedAreas: string): Promise<number[]> {
  const idSet = new Set<number>();
  
  if (affectedAreas === 'entire_facility') {
    const activeBays = await db
      .select({ id: bays.id })
      .from(bays)
      .where(eq(bays.isActive, true));
    activeBays.forEach(bay => idSet.add(bay.id));
    const allResources = await db.select({ id: resources.id }).from(resources);
    allResources.forEach(r => idSet.add(r.id));
    return Array.from(idSet);
  }
  
  if (affectedAreas === 'all_bays') {
    const activeBays = await db
      .select({ id: bays.id })
      .from(bays)
      .where(eq(bays.isActive, true));
    activeBays.forEach(bay => idSet.add(bay.id));
    return Array.from(idSet);
  }
  
  if (affectedAreas === 'conference_room' || affectedAreas === 'Conference Room') {
    const conferenceRoomId = await getConferenceRoomId();
    return conferenceRoomId ? [conferenceRoomId] : [];
  }
  
  if (affectedAreas.startsWith('bay_') && !affectedAreas.includes(',') && !affectedAreas.includes('[')) {
    const bayId = parseInt(affectedAreas.replace('bay_', ''));
    if (!isNaN(bayId)) {
      return [bayId];
    }
  }
  
  const conferenceRoomId = await getConferenceRoomId();
  
  try {
    const parsed = JSON.parse(affectedAreas);
    if (Array.isArray(parsed)) {
      for (const item of parsed) {
        if (typeof item === 'number') {
          idSet.add(item);
        } else if (typeof item === 'string') {
          if (item.startsWith('bay_')) {
            const bayId = parseInt(item.replace('bay_', ''));
            if (!isNaN(bayId)) idSet.add(bayId);
          } else if (item === 'conference_room' || item.toLowerCase() === 'conference room') {
            if (conferenceRoomId) idSet.add(conferenceRoomId);
          } else {
            const bayId = parseInt(item);
            if (!isNaN(bayId)) idSet.add(bayId);
          }
        }
      }
      if (idSet.size > 0) return Array.from(idSet);
    }
  } catch (parseError) {
    console.warn('[getAffectedBayIds] Failed to parse JSON affectedAreas:', affectedAreas, parseError);
  }
  
  const parts = affectedAreas.split(',').map(s => s.trim());
  
  for (const part of parts) {
    if (part.startsWith('bay_')) {
      const bayId = parseInt(part.replace('bay_', ''));
      if (!isNaN(bayId)) {
        idSet.add(bayId);
      }
    } else if (part === 'conference_room' || part.toLowerCase() === 'conference room') {
      if (conferenceRoomId) idSet.add(conferenceRoomId);
    } else if (part.match(/^Bay\s*(\d+)$/i)) {
      const match = part.match(/^Bay\s*(\d+)$/i);
      if (match) {
        idSet.add(parseInt(match[1]));
      }
    } else if (part.match(/^Simulator\s*Bay\s*(\d+)$/i)) {
      const match = part.match(/^Simulator\s*Bay\s*(\d+)$/i);
      if (match) {
        idSet.add(parseInt(match[1]));
      }
    } else {
      const parsed = parseInt(part);
      if (!isNaN(parsed)) {
        idSet.add(parsed);
      }
    }
  }
  
  return Array.from(idSet);
}

function getDatesBetween(startDate: string, endDate: string): string[] {
  const dates: string[] = [];
  let current = startDate;
  
  while (current <= endDate) {
    dates.push(current);
    current = addDaysToPacificDate(current, 1);
  }
  
  return dates;
}

async function formatAffectedAreasForDisplay(affectedAreas: string): Promise<string> {
  if (affectedAreas === 'entire_facility') return 'Entire Facility';
  if (affectedAreas === 'all_bays') return 'All Simulator Bays';
  if (affectedAreas === 'conference_room') return 'Conference Room';
  
  if (affectedAreas.startsWith('bay_')) {
    const bayId = parseInt(affectedAreas.replace('bay_', ''));
    if (!isNaN(bayId)) {
      const [bay] = await db.select({ name: bays.name }).from(bays).where(eq(bays.id, bayId));
      return bay ? bay.name : affectedAreas;
    }
  }
  
  return affectedAreas;
}

async function createAvailabilityBlocksForClosure(
  closureId: number,
  bayIds: number[],
  dates: string[],
  startTime: string | null,
  endTime: string | null,
  reason: string | null,
  createdBy: string | null
): Promise<void> {
  const blockStartTime = startTime || '08:00:00';
  const blockEndTime = endTime || '22:00:00';
  
  const insertValues = [];
  for (const bayId of bayIds) {
    for (const date of dates) {
      insertValues.push({
        bayId,
        blockDate: date,
        startTime: blockStartTime,
        endTime: blockEndTime,
        blockType: 'blocked',
        notes: reason || 'Facility closure',
        createdBy,
        closureId
      });
    }
  }
  
  if (insertValues.length > 0) {
    await db.insert(availabilityBlocks).values(insertValues);
    console.log(`[Closures] Created ${insertValues.length} availability blocks for closure #${closureId}`);
  }
}

async function deleteAvailabilityBlocksForClosure(closureId: number): Promise<void> {
  await db
    .delete(availabilityBlocks)
    .where(eq(availabilityBlocks.closureId, closureId));
  
  console.log(`[Closures] Deleted availability blocks for closure #${closureId}`);
}

async function createClosureCalendarEvents(
  calendarId: string,
  title: string,
  description: string,
  startDate: string,
  endDate: string,
  startTime: string | null,
  endTime: string | null
): Promise<string | null> {
  try {
    const calendar = await getGoogleCalendarClient();
    
    const isSameDay = startDate === endDate;
    const hasSpecificTimes = startTime && endTime;
    
    if (hasSpecificTimes) {
      const dates = getDatesBetween(startDate, endDate);
      const eventIds: string[] = [];
      
      for (const date of dates) {
        const startDateTime = createPacificDate(date, startTime);
        const endDateTime = createPacificDate(date, endTime);
        
        const event = {
          summary: title,
          description: `${description}${dates.length > 1 ? `\n\n(Day ${dates.indexOf(date) + 1} of ${dates.length})` : ''}`,
          start: {
            dateTime: startDateTime.toISOString(),
            timeZone: 'America/Los_Angeles',
          },
          end: {
            dateTime: endDateTime.toISOString(),
            timeZone: 'America/Los_Angeles',
          },
        };
        
        const response = await calendar.events.insert({
          calendarId,
          requestBody: event,
        });
        
        if (response.data.id) {
          eventIds.push(response.data.id);
        }
      }
      
      return eventIds.join(',');
    } else {
      const endDatePlusOne = addDaysToPacificDate(endDate, 1);
      
      const event = {
        summary: title,
        description,
        start: {
          date: startDate,
        },
        end: {
          date: endDatePlusOne,
        },
      };
      
      const response = await calendar.events.insert({
        calendarId,
        requestBody: event,
      });
      
      return response.data.id || null;
    }
  } catch (error) {
    console.error('Error creating closure calendar event:', error);
    return null;
  }
}

async function deleteClosureCalendarEvents(calendarId: string, eventIds: string): Promise<void> {
  const ids = eventIds.split(',').filter(id => id.trim());
  
  for (const eventId of ids) {
    try {
      await deleteCalendarEvent(eventId.trim(), calendarId);
    } catch (error) {
      console.error(`Failed to delete calendar event ${eventId}:`, error);
    }
  }
}

router.get('/api/closures', async (req, res) => {
  try {
    const results = await db
      .select()
      .from(facilityClosures)
      .where(eq(facilityClosures.isActive, true))
      .orderBy(facilityClosures.startDate, facilityClosures.startTime);
    res.json(results);
  } catch (error: any) {
    if (!isProduction) console.error('Closures fetch error:', error);
    res.status(500).json({ error: 'Failed to fetch closures' });
  }
});

router.post('/api/closures/sync', isStaffOrAdmin, async (req, res) => {
  try {
    console.log('[Manual Sync] Starting Internal Calendar closure sync...');
    const result = await syncInternalCalendarToClosures();
    
    if (result.error) {
      return res.status(400).json(result);
    }
    
    res.json({
      success: true,
      message: 'Closures synced successfully',
      stats: result
    });
  } catch (error: any) {
    if (!isProduction) console.error('Manual closure sync error:', error);
    res.status(500).json({ error: 'Failed to sync closures' });
  }
});

router.post('/api/closures', isStaffOrAdmin, async (req, res) => {
  try {
    const { 
      title, 
      reason, 
      start_date, 
      start_time,
      end_date, 
      end_time,
      affected_areas, 
      notify_members,
      created_by 
    } = req.body;
    
    if (!start_date || !affected_areas) {
      return res.status(400).json({ error: 'Start date and affected areas are required' });
    }
    
    const [result] = await db.insert(facilityClosures).values({
      title: title || 'Facility Closure',
      reason,
      startDate: start_date,
      startTime: start_time || null,
      endDate: end_date || start_date,
      endTime: end_time || null,
      affectedAreas: affected_areas,
      isActive: true,
      createdBy: created_by
    }).returning();
    
    const closureId = result.id;
    const affectedBayIds = await getAffectedBayIds(affected_areas);
    const dates = getDatesBetween(start_date, end_date || start_date);
    
    if (affectedBayIds.length > 0) {
      await createAvailabilityBlocksForClosure(
        closureId,
        affectedBayIds,
        dates,
        start_time,
        end_time,
        reason,
        created_by
      );
    }
    
    let golfEventIds: string | null = null;
    let conferenceEventIds: string | null = null;
    let internalEventIds: string | null = null;
    
    try {
      const golfCalendarId = await getCalendarIdByName(CALENDAR_CONFIG.golf.name);
      const affectedText = await formatAffectedAreasForDisplay(affected_areas);
          
      const eventTitle = `CLOSURE: ${title || 'Facility Closure'}`;
      const eventDescription = `${reason || 'Scheduled closure'}\n\nAffected: ${affectedText}`;
      
      // Determine what resources are affected
      const affectsConferenceRoom = affected_areas === 'entire_facility' || affected_areas === 'conference_room';
      const affectsBays = affected_areas === 'entire_facility' || affected_areas === 'all_bays' || 
        affected_areas.includes('bay_') || affectedBayIds.length > 0;
      
      // Create event in Booked Golf calendar (only if bays are affected)
      if (golfCalendarId && affectsBays) {
        golfEventIds = await createClosureCalendarEvents(
          golfCalendarId,
          eventTitle,
          eventDescription,
          start_date,
          end_date || start_date,
          start_time,
          end_time
        );
        
        if (golfEventIds) {
          console.log(`[Closures] Created Booked Golf calendar event(s) for closure #${closureId}`);
        }
      }
      
      // Create event in MBO_Conference_Room calendar (if conference room or entire facility is affected)
      if (affectsConferenceRoom) {
        const conferenceCalendarId = await getCalendarIdByName(CALENDAR_CONFIG.conference.name);
        if (conferenceCalendarId) {
          conferenceEventIds = await createClosureCalendarEvents(
            conferenceCalendarId,
            eventTitle,
            eventDescription,
            start_date,
            end_date || start_date,
            start_time,
            end_time
          );
          
          if (conferenceEventIds) {
            console.log(`[Closures] Created MBO_Conference_Room calendar event(s) for closure #${closureId}`);
          }
        }
      }
      
      // Always create event in Internal Calendar for all closures
      const internalCalendarId = await getCalendarIdByName(CALENDAR_CONFIG.internal.name);
      if (internalCalendarId) {
        internalEventIds = await createClosureCalendarEvents(
          internalCalendarId,
          eventTitle,
          eventDescription,
          start_date,
          end_date || start_date,
          start_time,
          end_time
        );
        
        if (internalEventIds) {
          console.log(`[Closures] Created Internal Calendar event(s) for closure #${closureId}`);
        }
      }
      
      // Store event IDs in separate columns
      if (golfEventIds || conferenceEventIds || internalEventIds) {
        await db
          .update(facilityClosures)
          .set({ 
            googleCalendarId: golfEventIds,
            conferenceCalendarId: conferenceEventIds,
            internalCalendarId: internalEventIds
          })
          .where(eq(facilityClosures.id, closureId));
      }
    } catch (calError) {
      console.error('[Closures] Failed to create calendar event:', calError);
    }
    
    if (notify_members) {
      const notificationTitle = title || 'Facility Closure';
      const affectedText = affected_areas === 'entire_facility' 
        ? 'Entire Facility' 
        : affected_areas === 'all_bays' 
          ? 'All Simulator Bays' 
          : affected_areas;
      const [sny, snm, snd] = start_date.split('-').map(Number);
      const monthsNotif = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      const startDateFormattedNotif = `${monthsNotif[snm - 1]} ${snd}`;
      const notificationBody = reason 
        ? `${reason} - ${affectedText} on ${startDateFormattedNotif}`
        : `${affectedText} will be closed on ${startDateFormattedNotif}`;
      
      const memberUsers = await db
        .select({ email: users.email })
        .from(users)
        .where(or(eq(users.role, 'member'), isNull(users.role)));
      
      // Filter out users with null/empty emails
      const membersWithEmails = memberUsers.filter(m => m.email && m.email.trim());
      
      if (membersWithEmails.length > 0) {
        const notificationValues = membersWithEmails.map(m => ({
          userEmail: m.email!,
          title: notificationTitle,
          message: notificationBody,
          type: 'closure',
          relatedId: closureId,
          relatedType: 'closure'
        }));
        
        await db.insert(notifications).values(notificationValues);
        console.log(`[Closures] Created in-app notifications for ${membersWithEmails.length} members`);
      }
      
      await sendPushNotificationToAllMembers({
        title: notificationTitle,
        body: notificationBody,
        url: '/announcements'
      });
    }
    
    res.json({ ...result, googleCalendarId: golfEventIds, conferenceCalendarId: conferenceEventIds, internalCalendarId: internalEventIds });
  } catch (error: any) {
    if (!isProduction) console.error('Closure create error:', error);
    res.status(500).json({ error: 'Failed to create closure' });
  }
});

router.delete('/api/closures/:id', isStaffOrAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const closureId = parseInt(id);
    
    const [closure] = await db
      .select()
      .from(facilityClosures)
      .where(eq(facilityClosures.id, closureId));
    
    // Delete calendar events from all calendars
    try {
      // Delete from Booked Golf calendar
      if (closure?.googleCalendarId) {
        const golfCalendarId = await getCalendarIdByName(CALENDAR_CONFIG.golf.name);
        if (golfCalendarId) {
          await deleteClosureCalendarEvents(golfCalendarId, closure.googleCalendarId);
          console.log(`[Closures] Deleted Booked Golf calendar event(s) for closure #${closureId}`);
        }
      }
      
      // Delete from MBO_Conference_Room calendar
      if (closure?.conferenceCalendarId) {
        const conferenceCalendarId = await getCalendarIdByName(CALENDAR_CONFIG.conference.name);
        if (conferenceCalendarId) {
          await deleteClosureCalendarEvents(conferenceCalendarId, closure.conferenceCalendarId);
          console.log(`[Closures] Deleted MBO_Conference_Room calendar event(s) for closure #${closureId}`);
        }
      }
      
      // Delete from Internal Calendar
      if (closure?.internalCalendarId) {
        const internalCalendarId = await getCalendarIdByName(CALENDAR_CONFIG.internal.name);
        if (internalCalendarId) {
          await deleteClosureCalendarEvents(internalCalendarId, closure.internalCalendarId);
          console.log(`[Closures] Deleted Internal Calendar event(s) for closure #${closureId}`);
        }
      }
    } catch (calError) {
      console.error('[Closures] Failed to delete calendar event:', calError);
    }
    
    await deleteAvailabilityBlocksForClosure(closureId);
    
    try {
      await db
        .delete(announcements)
        .where(eq(announcements.closureId, closureId));
      console.log(`[Closures] Deleted announcement(s) for closure #${closureId}`);
    } catch (announcementError) {
      console.error('[Closures] Failed to delete announcement:', announcementError);
    }
    
    await db
      .update(facilityClosures)
      .set({ isActive: false })
      .where(eq(facilityClosures.id, closureId));
    
    res.json({ success: true });
  } catch (error: any) {
    if (!isProduction) console.error('Closure delete error:', error);
    res.status(500).json({ error: 'Failed to delete closure' });
  }
});

// Update closure - also updates calendar events
router.put('/api/closures/:id', isStaffOrAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const closureId = parseInt(id);
    const { 
      title, 
      reason, 
      start_date, 
      start_time,
      end_date, 
      end_time,
      affected_areas
    } = req.body;
    
    // Get existing closure
    const [existing] = await db
      .select()
      .from(facilityClosures)
      .where(eq(facilityClosures.id, closureId));
    
    if (!existing) {
      return res.status(404).json({ error: 'Closure not found' });
    }
    
    // Update the closure record
    const [updated] = await db
      .update(facilityClosures)
      .set({
        title: title || existing.title,
        reason: reason !== undefined ? reason : existing.reason,
        startDate: start_date || existing.startDate,
        startTime: start_time !== undefined ? start_time : existing.startTime,
        endDate: end_date || existing.endDate,
        endTime: end_time !== undefined ? end_time : existing.endTime,
        affectedAreas: affected_areas || existing.affectedAreas
      })
      .where(eq(facilityClosures.id, closureId))
      .returning();
    
    // Update availability blocks if dates/times changed
    const datesChanged = start_date !== existing.startDate || end_date !== existing.endDate;
    const timesChanged = start_time !== existing.startTime || end_time !== existing.endTime;
    const areasChanged = affected_areas !== existing.affectedAreas;
    
    if (datesChanged || timesChanged || areasChanged) {
      // Delete old availability blocks and recreate
      await deleteAvailabilityBlocksForClosure(closureId);
      
      const newAffectedAreas = affected_areas || existing.affectedAreas;
      const affectedBayIds = await getAffectedBayIds(newAffectedAreas);
      const dates = getDatesBetween(
        start_date || existing.startDate,
        end_date || existing.endDate || start_date || existing.startDate
      );
      
      if (affectedBayIds.length > 0) {
        await createAvailabilityBlocksForClosure(
          closureId,
          affectedBayIds,
          dates,
          start_time !== undefined ? start_time : existing.startTime,
          end_time !== undefined ? end_time : existing.endTime,
          reason !== undefined ? reason : existing.reason,
          existing.createdBy
        );
      }
    }
    
    // Update calendar events if dates/times/title changed
    const hasCalendarEvents = existing.googleCalendarId || existing.conferenceCalendarId || existing.internalCalendarId;
    if (hasCalendarEvents && (datesChanged || timesChanged || title !== existing.title || reason !== existing.reason || areasChanged)) {
      try {
        const newAffectedAreas = affected_areas || existing.affectedAreas || 'entire_facility';
        const affectedText = await formatAffectedAreasForDisplay(newAffectedAreas);
            
        const eventTitle = `CLOSURE: ${title || existing.title}`;
        const eventDescription = `${reason !== undefined ? reason : existing.reason || 'Scheduled closure'}\n\nAffected: ${affectedText}`;
        const newStartDate = start_date || existing.startDate;
        const newEndDate = end_date || existing.endDate;
        const newStartTime = start_time !== undefined ? start_time : existing.startTime;
        const newEndTime = end_time !== undefined ? end_time : existing.endTime;
        
        const golfCalendarId = await getCalendarIdByName(CALENDAR_CONFIG.golf.name);
        const conferenceCalendarId = await getCalendarIdByName(CALENDAR_CONFIG.conference.name);
        const internalCalendarId = await getCalendarIdByName(CALENDAR_CONFIG.internal.name);
        
        // Delete old events from all calendars
        if (existing.googleCalendarId && golfCalendarId) {
          await deleteClosureCalendarEvents(golfCalendarId, existing.googleCalendarId);
        }
        if (existing.conferenceCalendarId && conferenceCalendarId) {
          await deleteClosureCalendarEvents(conferenceCalendarId, existing.conferenceCalendarId);
        }
        if (existing.internalCalendarId && internalCalendarId) {
          await deleteClosureCalendarEvents(internalCalendarId, existing.internalCalendarId);
        }
        
        // Create new events
        let newGolfEventIds: string | null = null;
        let newConferenceEventIds: string | null = null;
        let newInternalEventIds: string | null = null;
        
        // Determine what resources are affected
        const affectsConferenceRoom = newAffectedAreas === 'entire_facility' || newAffectedAreas === 'conference_room';
        const calendarAffectedBayIds = await getAffectedBayIds(newAffectedAreas);
        const affectsBays = newAffectedAreas === 'entire_facility' || newAffectedAreas === 'all_bays' || 
          newAffectedAreas.includes('bay_') || calendarAffectedBayIds.length > 0;
        
        // Create golf calendar event only if bays are affected
        if (golfCalendarId && affectsBays) {
          newGolfEventIds = await createClosureCalendarEvents(
            golfCalendarId,
            eventTitle,
            eventDescription,
            newStartDate,
            newEndDate || newStartDate,
            newStartTime,
            newEndTime
          );
        }
        
        // Create conference room calendar event if conference room or entire facility is affected
        if (conferenceCalendarId && affectsConferenceRoom) {
          newConferenceEventIds = await createClosureCalendarEvents(
            conferenceCalendarId,
            eventTitle,
            eventDescription,
            newStartDate,
            newEndDate || newStartDate,
            newStartTime,
            newEndTime
          );
        }
        
        // Always create Internal Calendar event for all closures
        if (internalCalendarId) {
          newInternalEventIds = await createClosureCalendarEvents(
            internalCalendarId,
            eventTitle,
            eventDescription,
            newStartDate,
            newEndDate || newStartDate,
            newStartTime,
            newEndTime
          );
        }
        
        // Update stored calendar IDs in separate columns
        await db
          .update(facilityClosures)
          .set({ 
            googleCalendarId: newGolfEventIds,
            conferenceCalendarId: newConferenceEventIds,
            internalCalendarId: newInternalEventIds
          })
          .where(eq(facilityClosures.id, closureId));
        
        console.log(`[Closures] Updated Google Calendar event(s) for closure #${closureId}`);
      } catch (calError) {
        console.error('[Closures] Failed to update calendar events:', calError);
      }
    }
    
    // Update linked announcement if exists
    try {
      const newAffectedAreas = affected_areas || existing.affectedAreas;
      const affectedText = newAffectedAreas === 'entire_facility' 
        ? 'Entire Facility' 
        : newAffectedAreas === 'all_bays' 
          ? 'All Simulator Bays' 
          : newAffectedAreas;
      
      const newStartDate = start_date || existing.startDate;
      const newEndDate = end_date || existing.endDate;
      const [usy, usm, usd] = newStartDate.split('-').map(Number);
      const monthsUpdate = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      const startDateFormatted = `${monthsUpdate[usm - 1]} ${usd}`;
      const endDateFormatted = newEndDate && newEndDate !== newStartDate 
        ? (() => { const [uey, uem, ued] = newEndDate.split('-').map(Number); return `${monthsUpdate[uem - 1]} ${ued}`; })()
        : null;
      
      const newStartTime = start_time !== undefined ? start_time : existing.startTime;
      const newEndTime = end_time !== undefined ? end_time : existing.endTime;
      const dateRange = endDateFormatted ? `${startDateFormatted} - ${endDateFormatted}` : startDateFormatted;
      const timeRange = newStartTime && newEndTime ? ` (${newStartTime} - ${newEndTime})` : newStartTime ? ` from ${newStartTime}` : '';
      
      const announcementTitle = title || existing.title;
      const announcementMessage = `${reason !== undefined ? reason : existing.reason || 'Scheduled maintenance'}\n\nAffected: ${affectedText}\nWhen: ${dateRange}${timeRange}`;
      
      await db
        .update(announcements)
        .set({
          title: announcementTitle,
          message: announcementMessage,
          startsAt: createPacificDate(newStartDate, '00:00:00'),
          endsAt: newEndDate ? createPacificDate(newEndDate, '23:59:59') : createPacificDate(newStartDate, '23:59:59')
        })
        .where(eq(announcements.closureId, closureId));
      
      console.log(`[Closures] Updated announcement for closure #${closureId}`);
    } catch (announcementError) {
      console.error('[Closures] Failed to update announcement:', announcementError);
    }
    
    res.json(updated);
  } catch (error: any) {
    if (!isProduction) console.error('Closure update error:', error);
    res.status(500).json({ error: 'Failed to update closure' });
  }
});

router.post('/api/closures/backfill-blocks', isStaffOrAdmin, async (req, res) => {
  try {
    const allClosures = await db
      .select()
      .from(facilityClosures)
      .where(eq(facilityClosures.isActive, true));
    
    let totalBlocksCreated = 0;
    const results: { closureId: number; title: string; blocksCreated: number }[] = [];
    
    for (const closure of allClosures) {
      const existingBlocks = await db
        .select({ id: availabilityBlocks.id })
        .from(availabilityBlocks)
        .where(eq(availabilityBlocks.closureId, closure.id));
      
      if (existingBlocks.length > 0) {
        results.push({ closureId: closure.id, title: closure.title, blocksCreated: 0 });
        continue;
      }
      
      const affectedBayIds = await getAffectedBayIds(closure.affectedAreas || 'entire_facility');
      const dates = getDatesBetween(closure.startDate, closure.endDate || closure.startDate);
      
      if (affectedBayIds.length > 0) {
        const blockStartTime = closure.startTime || '08:00:00';
        const blockEndTime = closure.endTime || '22:00:00';
        
        const insertValues = [];
        for (const bayId of affectedBayIds) {
          for (const date of dates) {
            insertValues.push({
              bayId,
              blockDate: date,
              startTime: blockStartTime,
              endTime: blockEndTime,
              blockType: 'blocked',
              notes: closure.reason || 'Facility closure',
              createdBy: closure.createdBy,
              closureId: closure.id
            });
          }
        }
        
        if (insertValues.length > 0) {
          await db.insert(availabilityBlocks).values(insertValues);
          totalBlocksCreated += insertValues.length;
          results.push({ closureId: closure.id, title: closure.title, blocksCreated: insertValues.length });
          console.log(`[Backfill] Created ${insertValues.length} blocks for closure #${closure.id}: ${closure.title}`);
        }
      } else {
        results.push({ closureId: closure.id, title: closure.title, blocksCreated: 0 });
      }
    }
    
    console.log(`[Backfill] Complete: ${totalBlocksCreated} total blocks created for ${allClosures.length} closures`);
    res.json({ 
      success: true, 
      totalClosures: allClosures.length,
      totalBlocksCreated,
      details: results 
    });
  } catch (error: any) {
    console.error('Backfill error:', error);
    res.status(500).json({ error: 'Failed to backfill availability blocks' });
  }
});

export default router;

```

### **3. Version Bump (`src/config/version.ts`)**

```typescript
export const APP_VERSION = '7.7';
export const LAST_UPDATED = '2025-12-30';

export function formatLastUpdated(): string {
  const [year, month, day] = LAST_UPDATED.split('-').map(Number);
  const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  return `${months[month - 1]} ${day}, ${year}`;
}

```

### **4. Changelog Update (`src/data/changelog.ts`)**

```typescript
export interface ChangelogEntry {
  version: string;
  date: string;
  title: string;
  isMajor?: boolean;
  changes: string[];
}

export const changelog: ChangelogEntry[] = [
  {
    version: "7.7",
    date: "2025-12-30",
    title: "Production Sync Enabled",
    isMajor: true,
    changes: [
      "All calendar synchronizations (Events, Wellness, Tours, Closures) now run in production environment",
      "Added manual sync button for closures to instantly fetch latest Internal Calendar events"
    ]
  },
  {
    version: "7.6",
    date: "2025-12-30",
    title: "Navigation Fix",
    changes: [
      "Closure card on dashboard now navigates to the Closures tab on Updates page"
    ]
  },
  {
    version: "7.5",
    date: "2025-12-30",
    title: "Wellness Time Display",
    changes: [
      "Wellness event times now display in reader-friendly 12-hour format with AM/PM"
    ]
  },
  {
    version: "7.4",
    date: "2025-12-30",
    title: "Flexible Booking Durations",
    changes: [
      "Core members can now select 30-minute or 60-minute durations for golf and conference room bookings"
    ]
  },
  {
    version: "7.3",
    date: "2025-12-30",
    title: "Closure Management Improvements",
    changes: [
      "Multi-select checkboxes for closure affected areas (select individual bays, conference room, or none)",
      "Blocks list now grouped by date with accordion-style expandable sections",
      "Fixed duplicate availability blocks being created for closures (with database constraint)",
      "Fixed date display in Blocks tab showing wrong day due to timezone",
      "Fixed calendar sync overwriting manual bay selections - closures now preserve selected affected areas",
      "Staff bottom nav now shows Closures instead of Inquiries for quick access",
      "Private calendar events now labeled as 'Private event' instead of 'Internal calendar event'"
    ]
  },
  {
    version: "7.2",
    date: "2025-12-30",
    title: "UI Polish",
    changes: [
      "Member search dropdown now has solid background for better readability in dark mode",
      "Updates page tabs now properly fit all text without overflow"
    ]
  },
  {
    version: "7.1",
    date: "2025-12-30",
    title: "Reschedule Workflow Improvements",
    changes: [
      "Staff notifications for reschedule requests now navigate to bookings page when tapped",
      "Original bay now shows as available when rescheduling an existing booking",
      "Admins using 'View As Member' can now cancel bookings on behalf of members",
      "Added 30-minute cutoff enforcement for last-minute reschedules"
    ]
  },
  {
    version: "7.0",
    date: "2025-12-30",
    title: "Tier-Based Booking Limits",
    isMajor: true,
    changes: [
      "Booking duration options now reflect tier settings from Manage Tiers page",
      "Core members see only 60-minute option, Premium/VIP see all durations",
      "Staff manual bookings can now create extended sessions (up to 5 hours) for private events",
      "Added Staff Notes field for internal notes on bookings (not visible to members)",
      "Dedicated Closures tab with red styling in Updates page",
      "Booking page closure cards now use red theme for consistency"
    ]
  },
  {
    version: "6.9",
    date: "2025-12-30",
    title: "Staff Tools & UX Polish",
    changes: [
      "Staff Updates now has 'Mark All as Read' and 'Dismiss All' buttons",
      "Booking page auto-scrolls through the entire flow: duration  time slots  bay selection  request button",
      "Removed divider line from Book a Tour modal for cleaner appearance",
      "Fixed white line appearing at bottom of navigation bar",
      "Updated Training Guide with FAB instructions, tier management, and View As Member details"
    ]
  },
  {
    version: "6.8",
    date: "2025-12-30",
    title: "UX Improvements",
    changes: [
      "Added 'Dismiss All' button to clear all notifications at once",
      "Booking page now auto-scrolls to time slots after selecting duration",
      "Booking page auto-scrolls to request button after selecting a bay/room",
      "Version History now shows newest updates at the top",
      "Fixed staff pages (Cafe Menu, Bug Reports, Version History) to open at top of page"
    ]
  },
  {
    version: "6.7",
    date: "2025-12-30",
    title: "Mobile App Fixes",
    changes: [
      "Members can now cancel their own bookings directly from the dashboard",
      "Next Booking card now displays correctly in dark mode",
      "Bottom navigation now properly hides on scroll on mobile Safari",
      "Improved touch gesture detection for smoother navigation hiding"
    ]
  },
  {
    version: "6.6",
    date: "2025-12-30",
    title: "Sync Reliability Improvements",
    changes: [
      "Sync buttons now automatically retry up to 3 times if network issues occur",
      "Fixed false 'sync failed' messages when Eventbrite is not configured",
      "Sync errors now clearly indicate which service had the issue",
      "Improved network error messages to be more user-friendly"
    ]
  },
  {
    version: "6.5",
    date: "2025-12-30",
    title: "Staff Bookings Reorganized",
    changes: [
      "Staff bookings dashboard now organized into 4 clear sections: Action Needed, Scheduled, Completed, and Cancellations",
      "Scheduled section shows upcoming bookings with Today, Tomorrow, and This Week filters",
      "Completed section shows attended and no-show bookings from the last 7 days",
      "Cancellations section shows declined and cancelled bookings from the last 30 days"
    ]
  },
  {
    version: "6.4",
    date: "2025-12-29",
    title: "Formatting Polish",
    changes: [
      "Phone numbers now display in a consistent (XXX) XXX-XXXX format across the app",
      "Staff profiles now show job title in the Account section",
      "Closures tab dates and times now use friendly formatting to match Blocks tab"
    ]
  },
  {
    version: "6.3",
    date: "2025-12-29",
    title: "Smart Data Refresh",
    changes: [
      "Booking page now auto-refreshes after submitting or cancelling a request",
      "Dashboard refreshes automatically when you return to the app",
      "Staff booking approvals and declines now instantly update the queue",
      "Pull-to-refresh works on all member pages for manual data updates"
    ]
  },
  {
    version: "6.2",
    date: "2025-12-29",
    title: "Staff Portal Polish",
    changes: [
      "Staff portal now respects your light/dark theme setting",
      "Light mode shows bone white background for a softer, cohesive look",
      "Upcoming Bookings now show an Edit button to quickly view or reschedule",
      "All staff and admin modals now open with smooth fade and pop animations",
      "Booking cards restyled with liquid glass design for a more cohesive look",
      "Conference Room column moved to the end of the calendar grid for clarity"
    ]
  },
  {
    version: "6.1",
    date: "2025-12-29",
    title: "Enhanced Admin Forms",
    changes: [
      "Add Class modal now uses a native time picker instead of text input",
      "Added optional image upload for wellness classes",
      "Added optional external URL field for classes and events  link members to booking pages or more info"
    ]
  },
  {
    version: "6.0",
    date: "2025-12-29",
    title: "Unified Updates Page",
    isMajor: true,
    changes: [
      "Consolidated announcements and closures into a single Updates page",
      "Closure alerts now appear at the top of the Announcements tab",
      "Removed the separate Announcements page  everything is now in Updates"
    ]
  },
  {
    version: "5.9",
    date: "2025-12-29",
    title: "Calendar Sync & Navigation Fixes",
    changes: [
      "Events and wellness classes are now automatically removed when deleted from Google Calendar",
      "Fixed closure card navigating to the wrong page  now correctly opens Updates",
      "Announcement cards now navigate to the unified Updates page"
    ]
  },
  {
    version: "5.8",
    date: "2025-12-29",
    title: "Accordion Time Slots & Closure Sorting",
    changes: [
      "Time slots are now grouped by hour in an accordion layout  tap an hour to see specific times",
      "Closures are now sorted from soonest to furthest on both member and staff views",
      "The closure alert card on the dashboard now shows the nearest upcoming closure first"
    ]
  },
  {
    version: "5.7",
    date: "2025-12-29",
    title: "Glass UI & Calendar Fix",
    changes: [
      "Members button and profile avatar now have a frosted glass effect",
      "Fixed Book a Tour modal appearing off-screen on some devices",
      "Fixed calendar events not importing on iPhone  now works reliably with Apple Calendar",
      "Added pull-to-refresh on Closures page to quickly sync data"
    ]
  },
  {
    version: "5.6",
    date: "2025-12-29",
    title: "Training Guide Updates",
    changes: [
      "Updated staff training guide with reschedule booking instructions",
      "Added documentation for 5-minute booking slot increments",
      "Documented 120-minute booking option for premium tier members"
    ]
  },
  {
    version: "5.5",
    date: "2025-12-28",
    title: "Booking Reliability & Animations",
    changes: [
      "Fixed booking cancellation errors in calendar view and decline modal",
      "Improved loading screen exit animation - now fluidly minimizes into status bar",
      "In-app notifications are now required for booking cancellations to succeed"
    ]
  },
  {
    version: "5.4",
    date: "2025-12-28",
    title: "Reschedule & 5-Min Booking Slots",
    changes: [
      "Reschedule bookings directly from calendar - old booking is automatically cancelled",
      "Time slots now increment by 5 minutes for more flexible scheduling",
      "Added 120-minute booking option for Premium, Corporate, and VIP members",
      "Manual bookings now appear on both member dashboard and admin calendar"
    ]
  },
  {
    version: "5.3",
    date: "2025-12-28",
    title: "UI Polish & Bug Fixes",
    changes: [
      "Fixed RSVP showing error message even when successful",
      "Fixed Add to Calendar showing false success on iOS Safari",
      "Improved event card text readability in light mode",
      "Fixed staff members unable to log in when added via Teams page",
      "Fixed Dashboard data not loading (bookings, RSVPs, wellness enrollments)",
      "Fixed various API calls across the app that could fail silently"
    ]
  },
  {
    version: "5.2",
    date: "2025-12-28",
    title: "Booking System Fixes",
    changes: [
      "Fixed booking cancellation for members from Dashboard",
      "Fixed member lookup in Manual Booking modal for staff",
      "Fixed request cancellation from My Requests tab",
      "Improved error messages when bookings fail to process"
    ]
  },
  {
    version: "5.1",
    date: "2025-12-28",
    title: "Staff Portal Refresh",
    changes: [
      "Pull to refresh now available on Staff portal pages",
      "Bookings, Tours, and Updates pages all support the new refresh gesture",
      "Same beautiful branded animation experience for staff members"
    ]
  },
  {
    version: "5.0",
    date: "2025-12-28",
    title: "Pull to Refresh",
    isMajor: true,
    changes: [
      "Pull down on any member page to refresh your data",
      "Beautiful branded green animation with animated mascot",
      "Loading screen fluidly shrinks into status bar when complete",
      "Data refreshes without full page reload for smoother experience"
    ]
  },
  {
    version: "4.9",
    date: "2025-12-28",
    title: "Modal Safe Area",
    changes: [
      "Book a Tour modal now opens within the safe viewing area on iOS",
      "Modal respects status bar and home indicator spacing"
    ]
  },
  {
    version: "4.8",
    date: "2025-12-28",
    title: "Gallery Loader Update",
    changes: [
      "Gallery page now uses the same fluid minimize-to-status-bar animation",
      "Consistent loading experience across all pages"
    ]
  },
  {
    version: "4.7",
    date: "2025-12-28",
    title: "Fluid Loading Exit",
    changes: [
      "Loading screen now fluidly minimizes into the status bar",
      "Content fades and shrinks smoothly during the transition",
      "Creates seamless visual connection between loading and status bar"
    ]
  },
  {
    version: "4.6",
    date: "2025-12-28",
    title: "Brand Green Status Bar",
    changes: [
      "Landing page now displays the signature Even House green behind the status bar",
      "Consistent branding on iOS PWA regardless of system light or dark mode",
      "Fixed Profile page animation flash during page transitions"
    ]
  },
  {
    version: "4.5",
    date: "2025-12-28",
    title: "Menu Mascot",
    changes: [
      "Mascot icon added to top left of side menu for quick home navigation",
      "Tap the mascot to return to the landing page instantly",
      "Mascot automatically switches between light and dark versions based on theme",
      "Cleaner menu layout with Home link replaced by mascot button"
    ]
  },
  {
    version: "4.4",
    date: "2025-12-28",
    title: "Parallax Preserved",
    changes: [
      "Refined hero background to maintain smooth parallax scrolling",
      "Background extends into safe area without breaking scroll effects",
      "Better structured layout for hero content and background layers"
    ]
  },
  {
    version: "4.3",
    date: "2025-12-28",
    title: "Full-Bleed Hero",
    changes: [
      "Hero image now extends edge-to-edge behind the status bar on iPhone",
      "Fixed-position hero background for true full-bleed display",
      "Seamless edge-to-edge display for a more immersive experience"
    ]
  },
  {
    version: "4.2",
    date: "2025-12-28",
    title: "Loading Animation",
    changes: [
      "Loading screen now slides up elegantly into the header bar",
      "Mascot and tagline gracefully fade up as the screen transitions",
      "Smoother, more polished app launch experience"
    ]
  },
  {
    version: "4.1",
    date: "2025-12-28",
    title: "Team Directory",
    changes: [
      "New Team section in Employee Resources for staff to view colleague contact info",
      "Staff can see phone numbers, emails, and job titles of team members",
      "Improved dark mode visibility for badge icons",
      "Admin-only features for adding, editing, and removing team members"
    ]
  },
  {
    version: "4.0",
    date: "2025-12-28",
    title: "Premium Feel",
    isMajor: true,
    changes: [
      "Hero images now have a subtle parallax depth effect as you scroll",
      "Scroll-reactive gradients shift gently to guide your eye",
      "Booking confirmations play a satisfying notification sound",
      "Glassmorphism styling refined for a cohesive, premium look",
      "Smoother animations throughout the app"
    ]
  },
  {
    version: "3.9",
    date: "2025-12-28",
    title: "Stability Check",
    changes: [
      "Ran a full check of all app features  everything working smoothly",
      "Verified all data loads correctly",
      "Confirmed error messages appear when they should",
      "No issues found  the app is running great"
    ]
  },
  {
    version: "3.8",
    date: "2025-12-28",
    title: "Login Fixes",
    changes: [
      "Fixed an issue that could briefly make the app unresponsive",
      "Login works better when using the app in a browser frame",
      "Training guide shows a clear message if your session expires",
      "Your login stays active more reliably as you use the app",
      "Fixed a bug where you might get logged out unexpectedly"
    ]
  },
  {
    version: "3.7",
    date: "2025-12-28",
    title: "Report Issues Easily",
    changes: [
      "New way to report bugs or issues right from your Profile",
      "You can attach a screenshot to show us what went wrong",
      "Staff can track and resolve reported issues",
      "See the status of your reports: open, in progress, or resolved"
    ]
  },
  {
    version: "3.6",
    date: "2025-12-28",
    title: "Simpler Navigation",
    changes: [
      "Cleaned up the side menu  fewer buttons, less clutter",
      "Access your portal from the header instead of the menu",
      "Contact page now has working links to Google Maps and Apple Maps"
    ]
  },
  {
    version: "3.5",
    date: "2025-12-27",
    title: "Training Guide Reliability",
    changes: [
      "Training guides update more reliably when we add new content",
      "New guides appear automatically without losing custom ones you've added",
      "Custom training guides you create are preserved during updates",
      "Fixed an issue where guide content could go missing"
    ]
  },
  {
    version: "3.4",
    date: "2025-12-27",
    title: "Better Notifications",
    changes: [
      "You'll now get notified when staff books something on your behalf",
      "The notification dot now disappears properly after you've seen your messages",
      "Cleaned up duplicate entries in your booking history",
      "Your dashboard shows all upcoming bookings, including ones staff made for you",
      "When one staff member handles a request, it clears from everyone's queue"
    ]
  },
  {
    version: "3.3",
    date: "2025-12-27",
    title: "Faster Loading",
    changes: [
      "Fixed a bug where the app could get stuck on the loading screen",
      "Loading animation fades out more smoothly",
      "Loading screen now always disappears within 2 seconds",
      "Better compatibility with all devices",
      "Pages signal when they're ready so you're not left waiting"
    ]
  },
  {
    version: "3.2",
    date: "2025-12-27",
    title: "Staff Portal Redesign",
    isMajor: true,
    changes: [
      "Reorganized Staff Portal navigation  Inquiries moved to bottom bar",
      "New Updates page showing your notifications and club announcements",
      "You can now share direct links to specific tabs",
      "Animations feel snappier throughout the app",
      "Training Guide redesigned with clearer layout",
      "Training Guide now supports images for each step",
      "Training Guide shows which pages each guide relates to",
      "Comprehensive how-to guides for all staff features",
      "Cleaner printing when you need a paper copy"
    ]
  },
  {
    version: "3.1",
    date: "2025-12-26",
    title: "Behind the Scenes",
    changes: [
      "Booking system now knows your membership tier for smarter limits",
      "Fixed 'View as Member' mode for staff testing the member experience",
      "Notification system now supports all message types"
    ]
  },
  {
    version: "3.0",
    date: "2025-12-26",
    title: "Visual Polish",
    changes: [
      "Buttons throughout the app now have consistent sizing",
      "Staff dashboard buttons look cleaner and more professional",
      "Wellness and Events sections now match visually",
      "Sync and integration icons are larger and easier to tap"
    ]
  },
  {
    version: "2.9",
    date: "2025-12-26",
    title: "Booking Improvements",
    changes: [
      "Booking pages load faster",
      "Your booking goes through even if there's a hiccup sending the confirmation",
      "Fixed an issue with closure-related notifications",
      "Staff get booking request alerts more reliably",
      "90-minute sessions now limited to Premium members and above",
      "All times display correctly for California (Pacific timezone)",
      "Same-day bookings only show times that are still available",
      "Past times no longer appear when booking",
      "Date picker now correctly shows which days you can book"
    ]
  },
  {
    version: "2.8",
    date: "2025-12-26",
    title: "Version History",
    changes: [
      "Staff can now see a full history of app updates",
      "Each update shows when it happened and what changed"
    ]
  },
  {
    version: "2.7",
    date: "2025-12-25",
    title: "Smoother Experience",
    changes: [
      "The top of your screen now matches the Even House green",
      "Closure notices appear right away  no refresh needed",
      "Landing page header fades in beautifully as you scroll",
      "New virtual membership card you can show at check-in",
      "Logo looks crisp on light backgrounds too",
      "Fixed a rare issue where two people signing up at once could cause problems",
      "Improved 'Add to Home Screen' prompts",
      "Subtle glass effect on the membership button",
      "Images load faster (optimized for the web)",
      "Better checks before canceling a booking"
    ]
  },
  {
    version: "2.6",
    date: "2025-12-25",
    title: "Your Info, Always Current",
    changes: [
      "Your membership tier updates automatically when you log in",
      "We now track when your membership started",
      "Staff can import member data from Mindbody and Trackman"
    ]
  },
  {
    version: "2.5",
    date: "2025-12-25",
    title: "Stay in the Loop",
    changes: [
      "In-app notifications keep you updated in real time",
      "Staff get alerted when new booking requests come in",
      "Push notifications available if you want them on your phone"
    ]
  },
  {
    version: "2.4",
    date: "2025-12-24",
    title: "Booking Requests",
    changes: [
      "Request a booking and staff will approve it  no more double-bookings",
      "Get notified when your request is approved or declined",
      "System prevents approving bookings over closures",
      "New 'My Requests' tab so you can track your pending bookings"
    ]
  },
  {
    version: "2.3",
    date: "2025-12-23",
    title: "Facility Closures",
    changes: [
      "Staff can now mark facilities as closed for maintenance or holidays",
      "Members automatically see closure announcements",
      "Closures appear on all relevant calendars",
      "Staff calendar shows clear red 'CLOSED' blocks"
    ]
  },
  {
    version: "2.2",
    date: "2025-12-22",
    title: "Calendar Sync",
    changes: [
      "Bookings now sync to four calendars: Golf Bays, Conference Room, Events, and Wellness",
      "Changes you make here show up in Google Calendar and vice versa"
    ]
  },
  {
    version: "2.1",
    date: "2025-12-21",
    title: "Easier & Safer Login",
    changes: [
      "Log in with a code sent to your email  no password to remember",
      "Your login stays active more reliably between visits",
      "Security improvements under the hood",
      "Tighter access controls for sensitive features"
    ]
  },
  {
    version: "2.0",
    date: "2025-12-20",
    title: "Staff Portal & Install as App",
    isMajor: true,
    changes: [
      "New Staff Portal with easy navigation for managing the club",
      "Quick-access dashboard for staff to jump to common tasks",
      "Install the app on your phone's home screen  works like a native app",
      "Pages load faster, even on slow connections",
      "Works properly on iPhones with the notch"
    ]
  },
  {
    version: "1.5",
    date: "2025-12-19",
    title: "Easy Inquiries",
    changes: [
      "Request a tour, ask about membership, or inquire about private events",
      "Your form submissions are saved even if you lose connection",
      "Staff can now view and manage all inquiries in one place"
    ]
  },
  {
    version: "1.4",
    date: "2025-12-19",
    title: "Membership Tiers",
    changes: [
      "Introduced membership levels: Social, Core, Premium, Corporate, and VIP",
      "Guest passes now work seamlessly  use one and it's deducted automatically",
      "Booking limits and perks adjust based on your membership tier"
    ]
  },
  {
    version: "1.3",
    date: "2025-12-18",
    title: "Better on Your Phone",
    changes: [
      "Subtle vibrations when you tap buttons (feels more responsive)",
      "Looks great on iPhone, iPad, and desktop",
      "Replaced text labels with cleaner logo icons"
    ]
  },
  {
    version: "1.2",
    date: "2025-12-18",
    title: "Book Your Bay",
    changes: [
      "Bay booking is here  see real-time availability and reserve your spot",
      "Syncs with Google Calendar so staff always know what's booked",
      "Choose your session length and only see times that actually work",
      "Easier to use for everyone, including screen reader users"
    ]
  },
  {
    version: "1.1",
    date: "2025-12-17",
    title: "New Look & Feel",
    changes: [
      "Logo now adjusts automatically for light and dark backgrounds",
      "Beautiful new fonts: elegant headlines and easy-to-read body text",
      "Consistent icons throughout the app",
      "Brand colors refined: Deep Green, Lavender, and Bone"
    ]
  },
  {
    version: "1.0",
    date: "2025-12-16",
    title: "Launch Day",
    isMajor: true,
    changes: [
      "The app is live! Built from the ground up for Even House members",
      "Connected to HubSpot so your membership info stays in sync",
      "Your profile page and private events are ready to explore",
      "Fresh branding with custom logos throughout"
    ]
  }
];


```